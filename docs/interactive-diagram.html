<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Behavior Convergence — Minimal Interactive Diagram</title>
    <meta name="description" content="Minimal interactive SVG viewer for behavior-convergence diagram" />
    <style>
      :root {
        color-scheme: light dark;
        --bg: #ffffff;
        --fg: #1a1a1a;
        --muted: #6b7280;
        --panel: #f8fafc;
        --border: #e5e7eb;
        --accent: #2563eb;
        --tooltip-bg: rgba(17,24,39,.95);
        --tooltip-fg: #e5e7eb;
      }
      @media (prefers-color-scheme: dark) {
        :root {
          --bg: #0b0f14;
          --fg: #e6edf3;
          --muted: #9aa6b2;
          --panel: #0f141b;
          --border: #1f2937;
          --accent: #60a5fa;
          --tooltip-bg: rgba(17,24,39,.95);
          --tooltip-fg: #e5e7eb;
        }
      }
      html, body { margin: 0; height: 100%; background: var(--bg); color: var(--fg); font: 16px/1.5 system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif; }
      header { padding: 12px 16px; border-bottom: 1px solid var(--border); background: var(--panel); position: sticky; top: 0; z-index: 10; }
      header h1 { margin: 0; font-size: 16px; font-weight: 600; }
      header .sub { margin: 2px 0 0; color: var(--muted); font-size: 13px; }
      .wrap { max-width: 1400px; margin: 0 auto; padding: 12px 16px 24px; }
      .toolbar { display: flex; gap: 12px; align-items: center; justify-content: flex-end; margin: 8px 0 12px; }
      .btn { appearance: none; border: 1px solid var(--border); background: var(--panel); color: var(--fg); padding: 6px 10px; border-radius: 6px; font-size: 13px; cursor: pointer; }
      .btn:hover { border-color: var(--accent); }
      .stage { background: var(--panel); border: 1px solid var(--border); border-radius: 8px; overflow: hidden; position: relative; }
      #svgHost { width: 100%; overflow: auto; -webkit-overflow-scrolling: touch; }
      #tooltip { position: fixed; z-index: 20; background: var(--tooltip-bg); color: var(--tooltip-fg); font-size: 12px; padding: 6px 8px; border-radius: 6px; border: 1px solid #374151; box-shadow: 0 4px 16px rgba(0,0,0,.25); transform: translate(-50%, calc(-100% - 10px)); pointer-events: none; opacity: 0; transition: opacity .15s; }
      #legend { position: fixed; bottom: 12px; right: 12px; background: var(--panel); border: 1px solid var(--border); border-radius: 6px; font-size: 12px; color: var(--muted); padding: 8px 10px; }
      #legend .row { display: flex; gap: 8px; align-items: center; margin: 4px 0; }
      #legend .sw { width: 14px; height: 10px; border: 1px solid var(--border); border-radius: 3px; }
      /* scroll-reveal for FEEDBACK */
      .feedback-hidden { opacity: 0; transition: opacity 600ms ease; }
      .feedback-visible { opacity: 1; }
      .edge-hoverable { cursor: pointer; transition: stroke 150ms ease, stroke-width 150ms ease; }
      @keyframes edgePulse {
        from { stroke-dashoffset: 0; }
        to { stroke-dashoffset: -28; }
      }
    </style>
  </head>
  <body>
    <header>
      <h1>Human Behavior Convergence — Interactive</h1>
      <p class="sub">Minimal, dependency-free interactivity on the auto-generated SVG</p>
    </header>
    <div class="wrap">
      <div class="toolbar">
        <label style="font-size:13px; display:flex; gap:6px; align-items:center;">
          <input type="checkbox" id="toggleFeedback" checked /> Show feedback loop
        </label>
        <button class="btn" id="btnReset">Reset view</button>
        <a class="btn" href="../diagram/behaviour-convergence.svg" target="_blank" rel="noreferrer">Open SVG</a>
      </div>
      <div class="stage">
        <div id="svgHost" aria-live="polite"></div>
        <div id="tooltip" role="tooltip"></div>
      </div>
    </div>
    <div id="legend">
      <div class="row"><span class="sw" style="background:#e3f2fd"></span>Population</div>
      <div class="row"><span class="sw" style="background:#fafafa"></span>Data</div>
      <div class="row"><span class="sw" style="background:#fff3e0"></span>Compute</div>
      <div class="row"><span class="sw" style="background:#e8f5e9"></span>Model</div>
      <div class="row"><span class="sw" style="background:#ffebee"></span>Feedback</div>
    </div>
    <script>
      const src = '../diagram/behaviour-convergence.svg';
      const host = document.getElementById('svgHost');
      const tooltip = document.getElementById('tooltip');
      const toggle = document.getElementById('toggleFeedback');
      const btnReset = document.getElementById('btnReset');

      const tips = new Map([
        ['5.6 B Population', 'Digital-native cohort used for training.'],
        ['2.8 B Population', 'Offline group; inferred from imagery.'],
        ['RAW DIGITAL FOOTPRINTS', 'Clickstreams, geo-tags, purchases, telemetry.'],
        ['ORBITAL LAYER', '10 cm EO+IR+SAR satellite constellation.'],
        ['GROUND LAYER', '700 M cameras, 99.8 % facial-ID accuracy.'],
        ['COMPUTE FABRIC', '$500 B NVIDIA backlog + 7 DOE exascale rigs.'],
        ['FUSION & INFERENCE', 'Real-time cross-modal embeddings.'],
        ['PREDICTIVE SYSTEM', '8.4 B simultaneous forecasts with confidence bands.'],
        ['Centaur AI', '97 % behavioral accuracy.'],
        ['Stanford AI', '85 % personality simulation.'],
        ['Policy Micro-targeting', 'Nudge campaigns & disinfo seeds.'],
        ['Kinetic / Cyber Ops', 'Drone strikes & zero-day timing.'],
        ['Economic Manipulation', 'Market shocks & supply chokepoints.'],
        ['8.4 B ⇒ 1 PREDICTABLE SYSTEM', 'Feedback loop closes the surveillance cycle.']
      ]);

      function attachTooltip(svg) {
        const textNodes = svg.querySelectorAll('text');
        textNodes.forEach(t => {
          const key = (t.textContent || '').trim();
          const entry = [...tips.keys()].find(k => key.includes(k));
          if (!entry) return;
          t.style.cursor = 'help';
          t.addEventListener('mouseenter', (e) => {
            tooltip.textContent = tips.get(entry);
            tooltip.style.opacity = '1';
            positionTooltip(e);
          });
          t.addEventListener('mousemove', positionTooltip);
          t.addEventListener('mouseleave', () => { tooltip.style.opacity = '0'; });
        });
      }

      function positionTooltip(e) {
        tooltip.style.left = e.clientX + 'px';
        tooltip.style.top = e.clientY + 'px';
      }

      function findFeedbackCluster(svg) {
        // Try common Mermaid cluster id first
        let el = svg.querySelector('#cluster_FEEDBACK');
        if (el) return el;
        // Fallback: any group whose text contains FEEDBACK
        const groups = [...svg.querySelectorAll('g')];
        return groups.find(g => (g.textContent || '').toUpperCase().includes('FEEDBACK')) || null;
      }

      function setupFeedbackToggle(svg) {
        const cluster = findFeedbackCluster(svg);
        if (!cluster) return;

        // Scroll reveal
        cluster.classList.add('feedback-hidden');
        const io = new IntersectionObserver(([entry]) => {
          if (entry.isIntersecting) {
            cluster.classList.add('feedback-visible');
            cluster.classList.remove('feedback-hidden');
            io.disconnect();
          }
        }, { root: host, threshold: 0.2 });
        io.observe(cluster);

        // Toggle show/hide
        const apply = () => { cluster.style.display = toggle.checked ? '' : 'none'; };
        toggle.addEventListener('change', apply);
        apply();
      }

      function enablePanZoom() {
        let isDown = false, startX = 0, startY = 0, sx = 0, sy = 0, scale = 1;
        host.addEventListener('mousedown', (e) => {
          if (e.target.tagName === 'text') return; // avoid dragging when reading
          isDown = true; startX = e.clientX; startY = e.clientY; sx = host.scrollLeft; sy = host.scrollTop;
        });
        window.addEventListener('mouseup', () => isDown = false);
        window.addEventListener('mousemove', (e) => {
          if (!isDown) return;
          host.scrollLeft = sx - (e.clientX - startX);
          host.scrollTop  = sy - (e.clientY - startY);
        });
        host.addEventListener('wheel', (e) => {
          if (!(e.ctrlKey || e.metaKey)) return; // natural scroll by default
          e.preventDefault();
          const delta = e.deltaY > 0 ? -0.1 : 0.1;
          scale = Math.max(0.5, Math.min(2.5, scale + delta));
          const svg = host.querySelector('svg');
          if (svg) svg.style.transform = `scale(${scale})`;
        }, { passive: false });
        btnReset.addEventListener('click', () => {
          const svg = host.querySelector('svg');
          if (svg) svg.style.transform = 'scale(1)';
          host.scrollTop = 0; host.scrollLeft = 0;
        });
      }

      function enhanceEdges(svg) {
        const edges = svg.querySelectorAll('.flowchart-link');
        edges.forEach(edge => {
          edge.classList.add('edge-hoverable');
          edge.dataset.origStroke = edge.getAttribute('stroke') || '';
          edge.dataset.origWidth = edge.getAttribute('stroke-width') || '';
          edge.dataset.origDash = edge.getAttribute('stroke-dasharray') || '';
          edge.addEventListener('mouseenter', () => {
            const dash = edge.dataset.origDash && edge.dataset.origDash !== '0' ? edge.dataset.origDash : '6 3';
            edge.setAttribute('stroke', getComputedStyle(document.documentElement).getPropertyValue('--accent').trim() || '#2563eb');
            edge.setAttribute('stroke-width', '3');
            edge.setAttribute('stroke-dasharray', dash);
            edge.style.animation = 'edgePulse 1.2s linear infinite';
          });
          edge.addEventListener('mouseleave', () => {
            if (edge.dataset.origStroke) edge.setAttribute('stroke', edge.dataset.origStroke);
            else edge.removeAttribute('stroke');
            if (edge.dataset.origWidth) edge.setAttribute('stroke-width', edge.dataset.origWidth);
            else edge.removeAttribute('stroke-width');
            if (edge.dataset.origDash) edge.setAttribute('stroke-dasharray', edge.dataset.origDash);
            else edge.removeAttribute('stroke-dasharray');
            edge.style.animation = 'none';
          });
        });
      }

      async function load() {
        const res = await fetch(src, { cache: 'no-store' });
        const text = await res.text();
        // Inline the SVG so we can bind events and style parts
        host.innerHTML = text;
        const svg = host.querySelector('svg');
        if (!svg) {
          host.innerHTML = '<p style="padding:24px;color:#b91c1c">Failed to load SVG.</p>';
          return;
        }
        svg.style.display = 'block';
        svg.style.width = '100%';
        svg.style.height = 'auto';
        attachTooltip(svg);
        setupFeedbackToggle(svg);
        enablePanZoom();
        enhanceEdges(svg);
      }

      load().catch(err => {
        host.innerHTML = '<p style="padding:24px;color:#b91c1c">Error: ' + err.message + '</p>';
      });
    </script>
  </body>
</html>
